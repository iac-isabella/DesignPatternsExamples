{"name":"Design Patterns : Composite and Decorator","tagline":"Trabalho 0 da disciplina de Programação Orientada a Objetos 2. Feito por Isabella de Albuquerque e Renan Cosmo.","body":"> Os padrões Composite e Decorator são padrões estruturais e estão relacionados a como classes e objetos são compostos de forma a gerar estruturas maiores e mais complexas.\r\n\r\n\r\n## Padrão Composite\r\n\r\n### Contexto e Aplicações\r\nComposite é um padrão de projeto de software utilizado para representar um objeto que é constituído pela composição de objetos similares a ele. Neste padrão, o objeto composto possui um conjunto de outros objetos que estão na mesma hierarquia de classes a que ele pertence.\r\nÉ utilizado sempre que é necessário representar elementos que são compostos por outros elementos similares.\r\nPor exemplo, em interfaces gráficas um elemento gráfico pode ser constituído pela composição de vários outros elementos gráficos. Uma janela pode conter um ou mais ícones, uma caixa de texto e vários outros elementos gráficos - até mesmo outra janela.\r\n\r\n**Resumindo:**\r\n\r\n* _Objetivo:_ Prover uma estrutura de árvore para representação eficiente de relações todo-parte.  \r\n* _Problema típico:_ Suponha uma estrutura de objetos relacionados a outros na forma de relações todo parte. A questão é: como fazer com que todos os objetos, tanto os \"todos\" como as \"partes\", possam ser manipulados de maneira idêntica por classes clientes, através de uma interface única? \r\n* _Solução:_ O padrão Composite propõe uma classe abstrata comum para objetos \"todo\" e \"parte\", contendo operações comuns a eles. Os objetos \"todo\" contêm listas de objetos \"partes\". Classes clientes acessam a mesma interface (a definida pela classe abstrata) tanto para objetos \"todo\" como para objetos \"parte\". \r\n\r\n###Exemplo\r\nPara fins de demonstração do uso do padrão composite segue um exemplo, cujo código será exibido em Java e em Scala. Este código se encontra disponível no GitHub no branch \"code\". Observe o diagrama de classes do exemplo:\r\n\r\n\r\n## Padrão Decorator\r\n\r\n### Contexto e Aplicações\r\nDecorator ou wrapper, é um padrão de projeto de software que permite adicionar um comportamento a um objeto já existente em tempo de execução, ou seja, agrega dinamicamente responsabilidades adicionais a um objeto.\r\nEle permite acrescentar ou remover responsabilidades a objetos individuais dinamicamente, de forma transparente e evita a explosão de subclasses para prover todas as combinações de responsabilidades.\r\n\r\n**Resumindo:**\r\n* _Objetivo:_ Estender a responsabilidade de um objeto dinamicamente, em tempo de execução, sem a necessidade de criação de subclasses. \r\n* _Problema típico:_ Suponha que um determinado objeto deva possuir novas responsabilidades em determinado momento de seu ciclo de utilização. A questão é: com fazer com que estas responsabilidades não sejam alocadas a todos os objetos da classe à qual pertence, já que elas são específicas dele, ou seja, como adicionar responsabilidades ao objeto quando o mesmo já foi criado? \r\n* _Solução:_ Criar uma classe que será a mãe da classe à qual o objeto pertence e de toda e qualquer responsabilidade adicional, que será chamada de classe decoradora. As responsabilidades adicionais serão derivadas desta classe. Estas farão referência à classe do objeto, adicionando o comportamento desejado.\r\n\r\n###Exemplo\r\nPara fins de demonstração do uso do padrão decorator segue um exemplo, cujo código será exibido em Java e em Scala. Este código se encontra disponível no GitHub no branch \"code\". Observe o diagrama de classes do exemplo:\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}